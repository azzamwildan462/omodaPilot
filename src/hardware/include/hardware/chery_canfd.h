/**
 * @file chery_canfd.h
 *
 * @brief This header file was generated by cantools version 40.5.0 Wed Sep 10 16:24:29 2025.
 *
 * @copyright Copyright (c) 2018-2019 Erik Moqvist
 *
 * @par License
 * The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef CHERY_CANFD_H
#define CHERY_CANFD_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define CHERY_CANFD_ENGINE_DATA_FRAME_ID (0x3eu)
#define CHERY_CANFD_STEER_SENSOR_FRAME_ID (0xc4u)
#define CHERY_CANFD_NEW_MSG_127_FRAME_ID (0x127u)
#define CHERY_CANFD_NEW_MSG_128_FRAME_ID (0x128u)
#define CHERY_CANFD_STEER_ANGLE_SENSOR_FRAME_ID (0x1d3u)
#define CHERY_CANFD_LKAS_FRAME_ID (0x1e3u)
#define CHERY_CANFD_NEW_MSG_260_FRAME_ID (0x260u)
#define CHERY_CANFD_NEW_MSG_287_FRAME_ID (0x287u)
#define CHERY_CANFD_BRAKE_DATA_FRAME_ID (0x29au)
#define CHERY_CANFD_NEW_MSG_2_E9_FRAME_ID (0x2e9u)
#define CHERY_CANFD_DOOR_FRAME_ID (0x2eau)
#define CHERY_CANFD_NEW_MSG_305_FRAME_ID (0x305u)
#define CHERY_CANFD_LKAS_STATE_FRAME_ID (0x307u)
#define CHERY_CANFD_WHEEL_SPEED_REAR_FRAME_ID (0x313u)
#define CHERY_CANFD_WHEEL_SPEED_FRNT_FRAME_ID (0x316u)
#define CHERY_CANFD_NEW_MSG_319_FRAME_ID (0x319u)
#define CHERY_CANFD_LKAS_CAM_CMD_345_FRAME_ID (0x345u)
#define CHERY_CANFD_STEER_BUTTON_FRAME_ID (0x360u)
#define CHERY_CANFD_SETTING_FRAME_ID (0x387u)
#define CHERY_CANFD_BCM_SIGNAL_2_FRAME_ID (0x391u)
#define CHERY_CANFD_BCM_SIGNAL_1_FRAME_ID (0x392u)
#define CHERY_CANFD_STEER_SENSOR_2_FRAME_ID (0x394u)
#define CHERY_CANFD_ACC_CMD_FRAME_ID (0x3a2u)
#define CHERY_CANFD_ACC_FRAME_ID (0x3a5u)
#define CHERY_CANFD_NEW_MSG_3_A7_FRAME_ID (0x3a7u)
#define CHERY_CANFD_NEW_MSG_3_AF_FRAME_ID (0x3afu)
#define CHERY_CANFD_NEW_MSG_3_DC_FRAME_ID (0x3dcu)
#define CHERY_CANFD_NEW_MSG_3_DE_FRAME_ID (0x3deu)
#define CHERY_CANFD_NEW_MSG_3_E2_FRAME_ID (0x3e2u)
#define CHERY_CANFD_LEAD_FRONT_FRAME_ID (0x3edu)
#define CHERY_CANFD_NEW_MSG_3_F0_FRAME_ID (0x3f0u)
#define CHERY_CANFD_LEAD_RIGHT_LEFT_FRAME_ID (0x3fau)
#define CHERY_CANFD_HUD_ALERT_FRAME_ID (0x3fcu)
#define CHERY_CANFD_NEW_MSG_40_F_FRAME_ID (0x40fu)
#define CHERY_CANFD_NEW_MSG_427_FRAME_ID (0x427u)
#define CHERY_CANFD_NEW_MSG_430_FRAME_ID (0x430u)
#define CHERY_CANFD_NEW_MSG_435_FRAME_ID (0x435u)
#define CHERY_CANFD_NEW_MSG_45_A_FRAME_ID (0x45au)
#define CHERY_CANFD_BSM_LEFT_FRAME_ID (0x4b1u)
#define CHERY_CANFD_BSM_RIGHT_FRAME_ID (0x4b3u)
#define CHERY_CANFD_NEW_MSG_4_DD_FRAME_ID (0x4ddu)
#define CHERY_CANFD_NEW_MSG_4_E3_FRAME_ID (0x4e3u)
#define CHERY_CANFD_BRAKE_SENSOR_FRAME_ID (0x4edu)
#define CHERY_CANFD_CARLINKO_FRAME_ID (0x4f2u)
#define CHERY_CANFD_EPB_FRAME_ID (0x4f6u)
#define CHERY_CANFD_WINDOW_COMMAND_FRAME_ID (0x4f8u)
#define CHERY_CANFD_AEB_COMMAND_FRAME_ID (0x4fcu)
#define CHERY_CANFD_NEW_MSG_51_B_FRAME_ID (0x51bu)
#define CHERY_CANFD_NEW_MSG_51_D_FRAME_ID (0x51du)
#define CHERY_CANFD_NEW_MSG_535_FRAME_ID (0x535u)
#define CHERY_CANFD_NEW_MSG_537_FRAME_ID (0x537u)

/* Frame lengths in bytes. */
#define CHERY_CANFD_ENGINE_DATA_LENGTH (48u)
#define CHERY_CANFD_STEER_SENSOR_LENGTH (8u)
#define CHERY_CANFD_NEW_MSG_127_LENGTH (8u)
#define CHERY_CANFD_NEW_MSG_128_LENGTH (8u)
#define CHERY_CANFD_STEER_ANGLE_SENSOR_LENGTH (8u)
#define CHERY_CANFD_LKAS_LENGTH (8u)
#define CHERY_CANFD_NEW_MSG_260_LENGTH (8u)
#define CHERY_CANFD_NEW_MSG_287_LENGTH (8u)
#define CHERY_CANFD_BRAKE_DATA_LENGTH (8u)
#define CHERY_CANFD_NEW_MSG_2_E9_LENGTH (8u)
#define CHERY_CANFD_DOOR_LENGTH (8u)
#define CHERY_CANFD_NEW_MSG_305_LENGTH (8u)
#define CHERY_CANFD_LKAS_STATE_LENGTH (8u)
#define CHERY_CANFD_WHEEL_SPEED_REAR_LENGTH (8u)
#define CHERY_CANFD_WHEEL_SPEED_FRNT_LENGTH (8u)
#define CHERY_CANFD_NEW_MSG_319_LENGTH (8u)
#define CHERY_CANFD_LKAS_CAM_CMD_345_LENGTH (8u)
#define CHERY_CANFD_STEER_BUTTON_LENGTH (6u)
#define CHERY_CANFD_SETTING_LENGTH (8u)
#define CHERY_CANFD_BCM_SIGNAL_2_LENGTH (8u)
#define CHERY_CANFD_BCM_SIGNAL_1_LENGTH (8u)
#define CHERY_CANFD_STEER_SENSOR_2_LENGTH (8u)
#define CHERY_CANFD_ACC_CMD_LENGTH (8u)
#define CHERY_CANFD_ACC_LENGTH (8u)
#define CHERY_CANFD_NEW_MSG_3_A7_LENGTH (24u)
#define CHERY_CANFD_NEW_MSG_3_AF_LENGTH (8u)
#define CHERY_CANFD_NEW_MSG_3_DC_LENGTH (8u)
#define CHERY_CANFD_NEW_MSG_3_DE_LENGTH (8u)
#define CHERY_CANFD_NEW_MSG_3_E2_LENGTH (8u)
#define CHERY_CANFD_LEAD_FRONT_LENGTH (8u)
#define CHERY_CANFD_NEW_MSG_3_F0_LENGTH (8u)
#define CHERY_CANFD_LEAD_RIGHT_LEFT_LENGTH (8u)
#define CHERY_CANFD_HUD_ALERT_LENGTH (8u)
#define CHERY_CANFD_NEW_MSG_40_F_LENGTH (8u)
#define CHERY_CANFD_NEW_MSG_427_LENGTH (8u)
#define CHERY_CANFD_NEW_MSG_430_LENGTH (8u)
#define CHERY_CANFD_NEW_MSG_435_LENGTH (8u)
#define CHERY_CANFD_NEW_MSG_45_A_LENGTH (8u)
#define CHERY_CANFD_BSM_LEFT_LENGTH (8u)
#define CHERY_CANFD_BSM_RIGHT_LENGTH (8u)
#define CHERY_CANFD_NEW_MSG_4_DD_LENGTH (8u)
#define CHERY_CANFD_NEW_MSG_4_E3_LENGTH (8u)
#define CHERY_CANFD_BRAKE_SENSOR_LENGTH (8u)
#define CHERY_CANFD_CARLINKO_LENGTH (8u)
#define CHERY_CANFD_EPB_LENGTH (2u)
#define CHERY_CANFD_WINDOW_COMMAND_LENGTH (8u)
#define CHERY_CANFD_AEB_COMMAND_LENGTH (8u)
#define CHERY_CANFD_NEW_MSG_51_B_LENGTH (8u)
#define CHERY_CANFD_NEW_MSG_51_D_LENGTH (8u)
#define CHERY_CANFD_NEW_MSG_535_LENGTH (8u)
#define CHERY_CANFD_NEW_MSG_537_LENGTH (8u)

/* Extended or standard frame types. */
#define CHERY_CANFD_ENGINE_DATA_IS_EXTENDED (0)
#define CHERY_CANFD_STEER_SENSOR_IS_EXTENDED (0)
#define CHERY_CANFD_NEW_MSG_127_IS_EXTENDED (0)
#define CHERY_CANFD_NEW_MSG_128_IS_EXTENDED (0)
#define CHERY_CANFD_STEER_ANGLE_SENSOR_IS_EXTENDED (0)
#define CHERY_CANFD_LKAS_IS_EXTENDED (0)
#define CHERY_CANFD_NEW_MSG_260_IS_EXTENDED (0)
#define CHERY_CANFD_NEW_MSG_287_IS_EXTENDED (0)
#define CHERY_CANFD_BRAKE_DATA_IS_EXTENDED (0)
#define CHERY_CANFD_NEW_MSG_2_E9_IS_EXTENDED (0)
#define CHERY_CANFD_DOOR_IS_EXTENDED (0)
#define CHERY_CANFD_NEW_MSG_305_IS_EXTENDED (0)
#define CHERY_CANFD_LKAS_STATE_IS_EXTENDED (0)
#define CHERY_CANFD_WHEEL_SPEED_REAR_IS_EXTENDED (0)
#define CHERY_CANFD_WHEEL_SPEED_FRNT_IS_EXTENDED (0)
#define CHERY_CANFD_NEW_MSG_319_IS_EXTENDED (0)
#define CHERY_CANFD_LKAS_CAM_CMD_345_IS_EXTENDED (0)
#define CHERY_CANFD_STEER_BUTTON_IS_EXTENDED (0)
#define CHERY_CANFD_SETTING_IS_EXTENDED (0)
#define CHERY_CANFD_BCM_SIGNAL_2_IS_EXTENDED (0)
#define CHERY_CANFD_BCM_SIGNAL_1_IS_EXTENDED (0)
#define CHERY_CANFD_STEER_SENSOR_2_IS_EXTENDED (0)
#define CHERY_CANFD_ACC_CMD_IS_EXTENDED (0)
#define CHERY_CANFD_ACC_IS_EXTENDED (0)
#define CHERY_CANFD_NEW_MSG_3_A7_IS_EXTENDED (0)
#define CHERY_CANFD_NEW_MSG_3_AF_IS_EXTENDED (0)
#define CHERY_CANFD_NEW_MSG_3_DC_IS_EXTENDED (0)
#define CHERY_CANFD_NEW_MSG_3_DE_IS_EXTENDED (0)
#define CHERY_CANFD_NEW_MSG_3_E2_IS_EXTENDED (0)
#define CHERY_CANFD_LEAD_FRONT_IS_EXTENDED (0)
#define CHERY_CANFD_NEW_MSG_3_F0_IS_EXTENDED (0)
#define CHERY_CANFD_LEAD_RIGHT_LEFT_IS_EXTENDED (0)
#define CHERY_CANFD_HUD_ALERT_IS_EXTENDED (0)
#define CHERY_CANFD_NEW_MSG_40_F_IS_EXTENDED (0)
#define CHERY_CANFD_NEW_MSG_427_IS_EXTENDED (0)
#define CHERY_CANFD_NEW_MSG_430_IS_EXTENDED (0)
#define CHERY_CANFD_NEW_MSG_435_IS_EXTENDED (0)
#define CHERY_CANFD_NEW_MSG_45_A_IS_EXTENDED (0)
#define CHERY_CANFD_BSM_LEFT_IS_EXTENDED (0)
#define CHERY_CANFD_BSM_RIGHT_IS_EXTENDED (0)
#define CHERY_CANFD_NEW_MSG_4_DD_IS_EXTENDED (0)
#define CHERY_CANFD_NEW_MSG_4_E3_IS_EXTENDED (0)
#define CHERY_CANFD_BRAKE_SENSOR_IS_EXTENDED (0)
#define CHERY_CANFD_CARLINKO_IS_EXTENDED (0)
#define CHERY_CANFD_EPB_IS_EXTENDED (0)
#define CHERY_CANFD_WINDOW_COMMAND_IS_EXTENDED (0)
#define CHERY_CANFD_AEB_COMMAND_IS_EXTENDED (0)
#define CHERY_CANFD_NEW_MSG_51_B_IS_EXTENDED (0)
#define CHERY_CANFD_NEW_MSG_51_D_IS_EXTENDED (0)
#define CHERY_CANFD_NEW_MSG_535_IS_EXTENDED (0)
#define CHERY_CANFD_NEW_MSG_537_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */
#define CHERY_CANFD_ENGINE_DATA_GEAR_P_CHOICE (1u)
#define CHERY_CANFD_ENGINE_DATA_GEAR_R_CHOICE (2u)
#define CHERY_CANFD_ENGINE_DATA_GEAR_N_CHOICE (3u)
#define CHERY_CANFD_ENGINE_DATA_GEAR_D_CHOICE (4u)

#define CHERY_CANFD_ENGINE_DATA_GEAR_BUTTON_PARK__PRESSED_CHOICE (1u)
#define CHERY_CANFD_ENGINE_DATA_GEAR_BUTTON_REVERSE__PRESSED_CHOICE (2u)
#define CHERY_CANFD_ENGINE_DATA_GEAR_BUTTON_NETRAL__PRESSED_CHOICE (3u)
#define CHERY_CANFD_ENGINE_DATA_GEAR_BUTTON_DRIVE__PRESSED_CHOICE (4u)

#define CHERY_CANFD_ENGINE_DATA_CC_STATE_NOT__AVAILABLE_CHOICE (0u)
#define CHERY_CANFD_ENGINE_DATA_CC_STATE_AVAILABLE_CHOICE (1u)
#define CHERY_CANFD_ENGINE_DATA_CC_STATE_ACTIVE_CHOICE (3u)

#define CHERY_CANFD_BCM_SIGNAL_1_SIGN_SIGNAL_RIGHT_CHOICE (1u)
#define CHERY_CANFD_BCM_SIGNAL_1_SIGN_SIGNAL_LEFT_CHOICE (2u)

#define CHERY_CANFD_BCM_SIGNAL_1_DOOR_LOCK_DOOR_LOCKED_CHOICE (0u)
#define CHERY_CANFD_BCM_SIGNAL_1_DOOR_LOCK_DOOR_UNLOCKED_CHOICE (1u)

#define CHERY_CANFD_EPB_EPB_SIGNAL_ACTIVE_RELEASE_CHOICE (0u)
#define CHERY_CANFD_EPB_EPB_SIGNAL_ACTIVE_LOCK_CHOICE (1u)
#define CHERY_CANFD_EPB_EPB_SIGNAL_RELEASE_CHOICE (2u)
#define CHERY_CANFD_EPB_EPB_SIGNAL_LOCK_CHOICE (3u)

#define CHERY_CANFD_WINDOW_COMMAND_NEW_SIGNAL_1_OPEN__DRIVER__WINDOW_CHOICE (3u)
#define CHERY_CANFD_WINDOW_COMMAND_NEW_SIGNAL_1_CLOSE__DRIVER__WINDOW_CHOICE (4u)

#define CHERY_CANFD_NEW_MSG_537_DRIVE_MODE_ECO__MODE_CHOICE (0u)
#define CHERY_CANFD_NEW_MSG_537_DRIVE_MODE_NORMAL__MODE_CHOICE (1u)
#define CHERY_CANFD_NEW_MSG_537_DRIVE_MODE_SPORT__MODE_CHOICE (2u)

/* Frame Names. */
#define CHERY_CANFD_ENGINE_DATA_NAME "ENGINE_DATA"
#define CHERY_CANFD_STEER_SENSOR_NAME "STEER_SENSOR"
#define CHERY_CANFD_NEW_MSG_127_NAME "NEW_MSG_127"
#define CHERY_CANFD_NEW_MSG_128_NAME "NEW_MSG_128"
#define CHERY_CANFD_STEER_ANGLE_SENSOR_NAME "STEER_ANGLE_SENSOR"
#define CHERY_CANFD_LKAS_NAME "LKAS"
#define CHERY_CANFD_NEW_MSG_260_NAME "NEW_MSG_260"
#define CHERY_CANFD_NEW_MSG_287_NAME "NEW_MSG_287"
#define CHERY_CANFD_BRAKE_DATA_NAME "BRAKE_DATA"
#define CHERY_CANFD_NEW_MSG_2_E9_NAME "NEW_MSG_2E9"
#define CHERY_CANFD_DOOR_NAME "DOOR"
#define CHERY_CANFD_NEW_MSG_305_NAME "NEW_MSG_305"
#define CHERY_CANFD_LKAS_STATE_NAME "LKAS_STATE"
#define CHERY_CANFD_WHEEL_SPEED_REAR_NAME "WHEEL_SPEED_REAR"
#define CHERY_CANFD_WHEEL_SPEED_FRNT_NAME "WHEEL_SPEED_FRNT"
#define CHERY_CANFD_NEW_MSG_319_NAME "NEW_MSG_319"
#define CHERY_CANFD_LKAS_CAM_CMD_345_NAME "LKAS_CAM_CMD_345"
#define CHERY_CANFD_STEER_BUTTON_NAME "STEER_BUTTON"
#define CHERY_CANFD_SETTING_NAME "SETTING"
#define CHERY_CANFD_BCM_SIGNAL_2_NAME "BCM_SIGNAL_2"
#define CHERY_CANFD_BCM_SIGNAL_1_NAME "BCM_SIGNAL_1"
#define CHERY_CANFD_STEER_SENSOR_2_NAME "STEER_SENSOR_2"
#define CHERY_CANFD_ACC_CMD_NAME "ACC_CMD"
#define CHERY_CANFD_ACC_NAME "ACC"
#define CHERY_CANFD_NEW_MSG_3_A7_NAME "NEW_MSG_3A7"
#define CHERY_CANFD_NEW_MSG_3_AF_NAME "NEW_MSG_3AF"
#define CHERY_CANFD_NEW_MSG_3_DC_NAME "NEW_MSG_3DC"
#define CHERY_CANFD_NEW_MSG_3_DE_NAME "NEW_MSG_3DE"
#define CHERY_CANFD_NEW_MSG_3_E2_NAME "NEW_MSG_3E2"
#define CHERY_CANFD_LEAD_FRONT_NAME "LEAD_FRONT"
#define CHERY_CANFD_NEW_MSG_3_F0_NAME "NEW_MSG_3F0"
#define CHERY_CANFD_LEAD_RIGHT_LEFT_NAME "LEAD_RIGHT_LEFT"
#define CHERY_CANFD_HUD_ALERT_NAME "HUD_ALERT"
#define CHERY_CANFD_NEW_MSG_40_F_NAME "NEW_MSG_40F"
#define CHERY_CANFD_NEW_MSG_427_NAME "NEW_MSG_427"
#define CHERY_CANFD_NEW_MSG_430_NAME "NEW_MSG_430"
#define CHERY_CANFD_NEW_MSG_435_NAME "NEW_MSG_435"
#define CHERY_CANFD_NEW_MSG_45_A_NAME "NEW_MSG_45A"
#define CHERY_CANFD_BSM_LEFT_NAME "BSM_LEFT"
#define CHERY_CANFD_BSM_RIGHT_NAME "BSM_RIGHT"
#define CHERY_CANFD_NEW_MSG_4_DD_NAME "NEW_MSG_4DD"
#define CHERY_CANFD_NEW_MSG_4_E3_NAME "NEW_MSG_4E3"
#define CHERY_CANFD_BRAKE_SENSOR_NAME "BRAKE_SENSOR"
#define CHERY_CANFD_CARLINKO_NAME "carlinko"
#define CHERY_CANFD_EPB_NAME "EPB"
#define CHERY_CANFD_WINDOW_COMMAND_NAME "Window_Command"
#define CHERY_CANFD_AEB_COMMAND_NAME "AEB_COMMAND"
#define CHERY_CANFD_NEW_MSG_51_B_NAME "NEW_MSG_51B"
#define CHERY_CANFD_NEW_MSG_51_D_NAME "NEW_MSG_51D"
#define CHERY_CANFD_NEW_MSG_535_NAME "NEW_MSG_535"
#define CHERY_CANFD_NEW_MSG_537_NAME "NEW_MSG_537"

/* Signal Names. */
#define CHERY_CANFD_ENGINE_DATA_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_ENGINE_DATA_NEW_SIGNAL_5_NAME "NEW_SIGNAL_5"
#define CHERY_CANFD_ENGINE_DATA_NEW_SIGNAL_4_NAME "NEW_SIGNAL_4"
#define CHERY_CANFD_ENGINE_DATA_NEW_SIGNAL_8_NAME "NEW_SIGNAL_8"
#define CHERY_CANFD_ENGINE_DATA_ACCEL_NAME "ACCEL"
#define CHERY_CANFD_ENGINE_DATA_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_ENGINE_DATA_GAS_POS_NAME "GAS_POS"
#define CHERY_CANFD_ENGINE_DATA_NEW_SIGNAL_9_NAME "NEW_SIGNAL_9"
#define CHERY_CANFD_ENGINE_DATA_NEW_SIGNAL_7_NAME "NEW_SIGNAL_7"
#define CHERY_CANFD_ENGINE_DATA_NEW_SIGNAL_13_NAME "NEW_SIGNAL_13"
#define CHERY_CANFD_ENGINE_DATA_NEW_SIGNAL_6_NAME "NEW_SIGNAL_6"
#define CHERY_CANFD_ENGINE_DATA_NEW_SIGNAL_15_NAME "NEW_SIGNAL_15"
#define CHERY_CANFD_ENGINE_DATA_NEW_SIGNAL_11_NAME "NEW_SIGNAL_11"
#define CHERY_CANFD_ENGINE_DATA_NEW_SIGNAL_12_NAME "NEW_SIGNAL_12"
#define CHERY_CANFD_ENGINE_DATA_GAS_NAME "GAS"
#define CHERY_CANFD_ENGINE_DATA_GEAR_NAME "GEAR"
#define CHERY_CANFD_ENGINE_DATA_GEAR_BUTTON_NAME "GEAR_BUTTON"
#define CHERY_CANFD_ENGINE_DATA_BRAKE_PRESS_NAME "BRAKE_PRESS"
#define CHERY_CANFD_ENGINE_DATA_CC_STATE_NAME "CC_STATE"
#define CHERY_CANFD_ENGINE_DATA_CRUIZE_SPEED_NAME "CRUIZE_SPEED"
#define CHERY_CANFD_ENGINE_DATA_SWITCH_TO_P_NAME "SWITCH_TO_P"
#define CHERY_CANFD_ENGINE_DATA_NEW_SIGNAL_3_NAME "NEW_SIGNAL_3"
#define CHERY_CANFD_ENGINE_DATA_NEW_SIGNAL_14_NAME "NEW_SIGNAL_14"
#define CHERY_CANFD_STEER_SENSOR_ANGLE_NAME "ANGLE"
#define CHERY_CANFD_STEER_SENSOR_FRACTION_NAME "FRACTION"
#define CHERY_CANFD_STEER_SENSOR_TORQUE_NAME "TORQUE"
#define CHERY_CANFD_STEER_SENSOR_TORQUE_DRIVER_NAME "TORQUE_DRIVER"
#define CHERY_CANFD_STEER_SENSOR_NEW_SIGNAL_3_NAME "NEW_SIGNAL_3"
#define CHERY_CANFD_NEW_MSG_127_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_NEW_MSG_127_NEW_SIGNAL_4_NAME "NEW_SIGNAL_4"
#define CHERY_CANFD_NEW_MSG_127_NEW_SIGNAL_3_NAME "NEW_SIGNAL_3"
#define CHERY_CANFD_NEW_MSG_127_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_NEW_MSG_128_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_STEER_ANGLE_SENSOR_STEER_ANGLE_NAME "STEER_ANGLE"
#define CHERY_CANFD_STEER_ANGLE_SENSOR_TORQUE_NAME "TORQUE"
#define CHERY_CANFD_STEER_ANGLE_SENSOR_COUNTER_NAME "COUNTER"
#define CHERY_CANFD_STEER_ANGLE_SENSOR_CHECKSUM_NAME "CHECKSUM"
#define CHERY_CANFD_LKAS_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_LKAS_NEW_SIGNAL_7_NAME "NEW_SIGNAL_7"
#define CHERY_CANFD_LKAS_NEW_SIGNAL_5_NAME "NEW_SIGNAL_5"
#define CHERY_CANFD_LKAS_LKAS_CMD_NAME "LKAS_CMD"
#define CHERY_CANFD_LKAS_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_LKAS_NEW_SIGNAL_3_NAME "NEW_SIGNAL_3"
#define CHERY_CANFD_LKAS_NEW_SIGNAL_4_NAME "NEW_SIGNAL_4"
#define CHERY_CANFD_LKAS_COUNTER_NAME "COUNTER"
#define CHERY_CANFD_LKAS_CHECKSUM_NAME "CHECKSUM"
#define CHERY_CANFD_NEW_MSG_260_NEW_SIGNAL_6_NAME "NEW_SIGNAL_6"
#define CHERY_CANFD_NEW_MSG_260_NEW_SIGNAL_3_NAME "NEW_SIGNAL_3"
#define CHERY_CANFD_NEW_MSG_260_NEW_SIGNAL_5_NAME "NEW_SIGNAL_5"
#define CHERY_CANFD_NEW_MSG_260_BRAKE_PRESS_NAME "BRAKE_PRESS"
#define CHERY_CANFD_NEW_MSG_260_NEW_SIGNAL_4_NAME "NEW_SIGNAL_4"
#define CHERY_CANFD_NEW_MSG_260_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_NEW_MSG_260_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_NEW_MSG_287_EPB_STATUS_NAME "EPB_STATUS"
#define CHERY_CANFD_NEW_MSG_287_SEATBELT_LOCK_NAME "SEATBELT_LOCK"
#define CHERY_CANFD_BRAKE_DATA_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_BRAKE_DATA_BRAKE_POS_NAME "BRAKE_POS"
#define CHERY_CANFD_DOOR_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_DOOR_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_NEW_MSG_305_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_NEW_MSG_305_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_LKAS_STATE_NEW_SIGNAL_3_NAME "NEW_SIGNAL_3"
#define CHERY_CANFD_LKAS_STATE_NEW_SIGNAL_4_NAME "NEW_SIGNAL_4"
#define CHERY_CANFD_LKAS_STATE_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_LKAS_STATE_STATE_NAME "STATE"
#define CHERY_CANFD_LKAS_STATE_LKA_ACTIVE_NAME "LKA_ACTIVE"
#define CHERY_CANFD_LKAS_STATE_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_LKAS_STATE_COUNTER_NAME "COUNTER"
#define CHERY_CANFD_LKAS_STATE_CHECKSUM_NAME "CHECKSUM"
#define CHERY_CANFD_WHEEL_SPEED_REAR_WHEEL_SPEED_RR_NAME "WHEEL_SPEED_RR"
#define CHERY_CANFD_WHEEL_SPEED_REAR_WHEEL_SPEED_RL_NAME "WHEEL_SPEED_RL"
#define CHERY_CANFD_WHEEL_SPEED_REAR_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_WHEEL_SPEED_FRNT_WHEEL_SPEED_FR_NAME "WHEEL_SPEED_FR"
#define CHERY_CANFD_WHEEL_SPEED_FRNT_WHEEL_SPEED_FL_NAME "WHEEL_SPEED_FL"
#define CHERY_CANFD_WHEEL_SPEED_FRNT_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_WHEEL_SPEED_FRNT_STOPPED_NAME "STOPPED"
#define CHERY_CANFD_LKAS_CAM_CMD_345_CMD_NAME "CMD"
#define CHERY_CANFD_LKAS_CAM_CMD_345_LKA_ACTIVE_NAME "LKA_ACTIVE"
#define CHERY_CANFD_LKAS_CAM_CMD_345_SET_X0_NAME "SET_X0"
#define CHERY_CANFD_LKAS_CAM_CMD_345_NEW_SIGNAL_5_NAME "NEW_SIGNAL_5"
#define CHERY_CANFD_LKAS_CAM_CMD_345_NEW_SIGNAL_6_NAME "NEW_SIGNAL_6"
#define CHERY_CANFD_LKAS_CAM_CMD_345_NEW_SIGNAL_7_NAME "NEW_SIGNAL_7"
#define CHERY_CANFD_LKAS_CAM_CMD_345_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_LKAS_CAM_CMD_345_CHECKSUM_NAME "CHECKSUM"
#define CHERY_CANFD_STEER_BUTTON_CHECKSUM_NAME "CHECKSUM"
#define CHERY_CANFD_STEER_BUTTON_COUNTER_NAME "COUNTER"
#define CHERY_CANFD_STEER_BUTTON_RES_PLUS_NAME "RES_PLUS"
#define CHERY_CANFD_STEER_BUTTON_CC_BTN_NAME "CC_BTN"
#define CHERY_CANFD_STEER_BUTTON_ACC_NAME "ACC"
#define CHERY_CANFD_STEER_BUTTON_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_STEER_BUTTON_RES_MINUS_NAME "RES_MINUS"
#define CHERY_CANFD_STEER_BUTTON_GAP_ADJUST_UP_NAME "GAP_ADJUST_UP"
#define CHERY_CANFD_STEER_BUTTON_GAP_ADJUST_DOWN_NAME "GAP_ADJUST_DOWN"
#define CHERY_CANFD_SETTING_CANCEL_ALERT_NAME "CANCEL_ALERT"
#define CHERY_CANFD_SETTING_NEW_SIGNAL_6_NAME "NEW_SIGNAL_6"
#define CHERY_CANFD_SETTING_SHOW_AEB_NAME "SHOW_AEB"
#define CHERY_CANFD_SETTING_GAP_NAME "GAP"
#define CHERY_CANFD_SETTING_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_SETTING_NEW_SIGNAL_3_NAME "NEW_SIGNAL_3"
#define CHERY_CANFD_SETTING_ACC_AVAILABLE_NAME "ACC_AVAILABLE"
#define CHERY_CANFD_SETTING_ACC_ACTIVE_NAME "ACC_ACTIVE"
#define CHERY_CANFD_SETTING_AEB_ACTIVE_NAME "AEB_ACTIVE"
#define CHERY_CANFD_SETTING_CC_SPEED_NAME "CC_SPEED"
#define CHERY_CANFD_SETTING_COUNTER_NAME "COUNTER"
#define CHERY_CANFD_SETTING_CHECKSUM_NAME "CHECKSUM"
#define CHERY_CANFD_BCM_SIGNAL_2_NEW_SIGNAL_6_NAME "NEW_SIGNAL_6"
#define CHERY_CANFD_BCM_SIGNAL_2_HIGH_BEAM_NAME "HIGH_BEAM"
#define CHERY_CANFD_BCM_SIGNAL_2_LEFT_SIGN_NAME "LEFT_SIGN"
#define CHERY_CANFD_BCM_SIGNAL_2_RIGHT_SIGN_NAME "RIGHT_SIGN"
#define CHERY_CANFD_BCM_SIGNAL_2_STATUS_NAME "STATUS"
#define CHERY_CANFD_BCM_SIGNAL_2_DOOR_LOCK_OPEN_NAME "DOOR_LOCK_OPEN"
#define CHERY_CANFD_BCM_SIGNAL_2_NEW_SIGNAL_8_NAME "NEW_SIGNAL_8"
#define CHERY_CANFD_BCM_SIGNAL_2_NEW_SIGNAL_11_NAME "NEW_SIGNAL_11"
#define CHERY_CANFD_BCM_SIGNAL_2_NEW_SIGNAL_3_NAME "NEW_SIGNAL_3"
#define CHERY_CANFD_BCM_SIGNAL_2_NEW_SIGNAL_5_NAME "NEW_SIGNAL_5"
#define CHERY_CANFD_BCM_SIGNAL_2_RIGHT_SIGN_PRESSED_NAME "RIGHT_SIGN_PRESSED"
#define CHERY_CANFD_BCM_SIGNAL_2_LEFT_SIGN_PRESSED_NAME "LEFT_SIGN_PRESSED"
#define CHERY_CANFD_BCM_SIGNAL_2_WIPER_BUTTON_NAME "WIPER_BUTTON"
#define CHERY_CANFD_BCM_SIGNAL_2_NEW_SIGNAL_9_NAME "NEW_SIGNAL_9"
#define CHERY_CANFD_BCM_SIGNAL_2_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_BCM_SIGNAL_1_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_BCM_SIGNAL_1_SIGN_SIGNAL_NAME "SIGN_SIGNAL"
#define CHERY_CANFD_BCM_SIGNAL_1_DOOR_LOCK_NAME "DOOR_LOCK"
#define CHERY_CANFD_BCM_SIGNAL_1_RL_DOOR_OPEN_NAME "RL_DOOR_OPEN"
#define CHERY_CANFD_BCM_SIGNAL_1_RR_DOOR_OPEN_NAME "RR_DOOR_OPEN"
#define CHERY_CANFD_BCM_SIGNAL_1_FL_DOOR_OPEN_NAME "FL_DOOR_OPEN"
#define CHERY_CANFD_BCM_SIGNAL_1_FR_DOOR_OPEN_NAME "FR_DOOR_OPEN"
#define CHERY_CANFD_BCM_SIGNAL_1_NEW_SIGNAL_3_NAME "NEW_SIGNAL_3"
#define CHERY_CANFD_BCM_SIGNAL_1_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_STEER_SENSOR_2_TORQUE_DRIVER_NAME "TORQUE_DRIVER"
#define CHERY_CANFD_STEER_SENSOR_2_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_ACC_CMD_ACCEL_ON_NAME "ACCEL_ON"
#define CHERY_CANFD_ACC_CMD_CMD_NAME "CMD"
#define CHERY_CANFD_ACC_CMD_ACC_STATE_2_NAME "ACC_STATE_2"
#define CHERY_CANFD_ACC_CMD_STOPPED_NAME "STOPPED"
#define CHERY_CANFD_ACC_CMD_ACC_STATE_NAME "ACC_STATE"
#define CHERY_CANFD_ACC_CMD_STOPPING_NAME "STOPPING"
#define CHERY_CANFD_ACC_CMD_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_ACC_CMD_NEW_SIGNAL_9_NAME "NEW_SIGNAL_9"
#define CHERY_CANFD_ACC_CMD_NEW_SIGNAL_12_NAME "NEW_SIGNAL_12"
#define CHERY_CANFD_ACC_CMD_NEW_SIGNAL_6_NAME "NEW_SIGNAL_6"
#define CHERY_CANFD_ACC_CMD_NEW_SIGNAL_5_NAME "NEW_SIGNAL_5"
#define CHERY_CANFD_ACC_CMD_NEW_SIGNAL_8_NAME "NEW_SIGNAL_8"
#define CHERY_CANFD_ACC_CMD_NEW_SIGNAL_13_NAME "NEW_SIGNAL_13"
#define CHERY_CANFD_ACC_CMD_NEW_SIGNAL_10_NAME "NEW_SIGNAL_10"
#define CHERY_CANFD_ACC_CMD_NEW_SIGNAL_3_NAME "NEW_SIGNAL_3"
#define CHERY_CANFD_ACC_CMD_NEW_SIGNAL_4_NAME "NEW_SIGNAL_4"
#define CHERY_CANFD_ACC_CMD_GAS_PRESSED_NAME "GAS_PRESSED"
#define CHERY_CANFD_ACC_CMD_COUNTER_NAME "COUNTER"
#define CHERY_CANFD_ACC_CMD_NEW_SIGNAL_11_NAME "NEW_SIGNAL_11"
#define CHERY_CANFD_ACC_CMD_CHECKSUM_NAME "CHECKSUM"
#define CHERY_CANFD_ACC_NEW_SIGNAL_7_NAME "NEW_SIGNAL_7"
#define CHERY_CANFD_ACC_NEW_SIGNAL_10_NAME "NEW_SIGNAL_10"
#define CHERY_CANFD_ACC_NEW_SIGNAL_8_NAME "NEW_SIGNAL_8"
#define CHERY_CANFD_ACC_NEW_SIGNAL_9_NAME "NEW_SIGNAL_9"
#define CHERY_CANFD_ACC_NEW_SIGNAL_6_NAME "NEW_SIGNAL_6"
#define CHERY_CANFD_ACC_NEW_SIGNAL_11_NAME "NEW_SIGNAL_11"
#define CHERY_CANFD_ACC_NEW_SIGNAL_5_NAME "NEW_SIGNAL_5"
#define CHERY_CANFD_ACC_NEW_SIGNAL_4_NAME "NEW_SIGNAL_4"
#define CHERY_CANFD_ACC_GAS_PRESSED_NAME "GAS_PRESSED"
#define CHERY_CANFD_ACC_ACC_ACTIVE_NAME "ACC_ACTIVE"
#define CHERY_CANFD_ACC_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_ACC_NEW_SIGNAL_12_NAME "NEW_SIGNAL_12"
#define CHERY_CANFD_ACC_AEB_ACTIVE_NAME "AEB_ACTIVE"
#define CHERY_CANFD_ACC_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_ACC_COUNTER_NAME "COUNTER"
#define CHERY_CANFD_ACC_CHECKSUM_NAME "CHECKSUM"
#define CHERY_CANFD_NEW_MSG_3_AF_NEW_SIGNAL_3_NAME "NEW_SIGNAL_3"
#define CHERY_CANFD_NEW_MSG_3_AF_NEW_SIGNAL_5_NAME "NEW_SIGNAL_5"
#define CHERY_CANFD_NEW_MSG_3_AF_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_NEW_MSG_3_AF_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_NEW_MSG_3_AF_CHECKSUM_NAME "CHECKSUM"
#define CHERY_CANFD_NEW_MSG_3_DC_NEW_SIGNAL_8_NAME "NEW_SIGNAL_8"
#define CHERY_CANFD_NEW_MSG_3_DC_NEW_SIGNAL_6_NAME "NEW_SIGNAL_6"
#define CHERY_CANFD_NEW_MSG_3_DC_NEW_SIGNAL_5_NAME "NEW_SIGNAL_5"
#define CHERY_CANFD_NEW_MSG_3_DC_NEW_SIGNAL_7_NAME "NEW_SIGNAL_7"
#define CHERY_CANFD_NEW_MSG_3_DC_AEB_MAYBE_NAME "AEB_MAYBE"
#define CHERY_CANFD_NEW_MSG_3_DC_NEW_SIGNAL_4_NAME "NEW_SIGNAL_4"
#define CHERY_CANFD_NEW_MSG_3_DC_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_NEW_MSG_3_DC_NEW_SIGNAL_3_NAME "NEW_SIGNAL_3"
#define CHERY_CANFD_NEW_MSG_3_DC_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_NEW_MSG_3_DC_COUNTER_NAME "COUNTER"
#define CHERY_CANFD_NEW_MSG_3_DC_CHECKSUM_NAME "CHECKSUM"
#define CHERY_CANFD_NEW_MSG_3_DE_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_NEW_MSG_3_DE_NEW_SIGNAL_5_NAME "NEW_SIGNAL_5"
#define CHERY_CANFD_NEW_MSG_3_DE_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_NEW_MSG_3_DE_NEW_SIGNAL_6_NAME "NEW_SIGNAL_6"
#define CHERY_CANFD_NEW_MSG_3_DE_NEW_SIGNAL_4_NAME "NEW_SIGNAL_4"
#define CHERY_CANFD_NEW_MSG_3_DE_NEW_SIGNAL_7_NAME "NEW_SIGNAL_7"
#define CHERY_CANFD_NEW_MSG_3_DE_NEW_SIGNAL_3_NAME "NEW_SIGNAL_3"
#define CHERY_CANFD_NEW_MSG_3_E2_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_NEW_MSG_3_E2_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_LEAD_FRONT_NEW_SIGNAL_7_NAME "NEW_SIGNAL_7"
#define CHERY_CANFD_LEAD_FRONT_VALID_SIGNAL_NAME "VALID_SIGNAL"
#define CHERY_CANFD_LEAD_FRONT_NEW_SIGNAL_3_NAME "NEW_SIGNAL_3"
#define CHERY_CANFD_LEAD_FRONT_LEAD_DISTANCE_NAME "LEAD_DISTANCE"
#define CHERY_CANFD_LEAD_FRONT_NEW_SIGNAL_6_NAME "NEW_SIGNAL_6"
#define CHERY_CANFD_LEAD_FRONT_NEW_SIGNAL_4_NAME "NEW_SIGNAL_4"
#define CHERY_CANFD_LEAD_FRONT_NEW_SIGNAL_9_NAME "NEW_SIGNAL_9"
#define CHERY_CANFD_LEAD_FRONT_NEW_SIGNAL_8_NAME "NEW_SIGNAL_8"
#define CHERY_CANFD_LEAD_FRONT_NEW_SIGNAL_5_NAME "NEW_SIGNAL_5"
#define CHERY_CANFD_LEAD_FRONT_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_LEAD_FRONT_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_LEAD_RIGHT_LEFT_NEW_SIGNAL_3_NAME "NEW_SIGNAL_3"
#define CHERY_CANFD_LEAD_RIGHT_LEFT_NEW_SIGNAL_9_NAME "NEW_SIGNAL_9"
#define CHERY_CANFD_LEAD_RIGHT_LEFT_NEW_SIGNAL_8_NAME "NEW_SIGNAL_8"
#define CHERY_CANFD_LEAD_RIGHT_LEFT_VALID_SIGNAL_NAME "VALID_SIGNAL"
#define CHERY_CANFD_LEAD_RIGHT_LEFT_LEAD_LEFT_NAME "LEAD_LEFT"
#define CHERY_CANFD_LEAD_RIGHT_LEFT_NEW_SIGNAL_4_NAME "NEW_SIGNAL_4"
#define CHERY_CANFD_LEAD_RIGHT_LEFT_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_LEAD_RIGHT_LEFT_NEW_SIGNAL_7_NAME "NEW_SIGNAL_7"
#define CHERY_CANFD_LEAD_RIGHT_LEFT_VALID_SIGNAL_2_NAME "VALID_SIGNAL_2"
#define CHERY_CANFD_LEAD_RIGHT_LEFT_LEAD_RIGHT_NAME "LEAD_RIGHT"
#define CHERY_CANFD_LEAD_RIGHT_LEFT_NEW_SIGNAL_6_NAME "NEW_SIGNAL_6"
#define CHERY_CANFD_LEAD_RIGHT_LEFT_NEW_SIGNAL_5_NAME "NEW_SIGNAL_5"
#define CHERY_CANFD_LEAD_RIGHT_LEFT_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_HUD_ALERT_NEW_SIGNAL_6_NAME "NEW_SIGNAL_6"
#define CHERY_CANFD_HUD_ALERT_NEW_SIGNAL_7_NAME "NEW_SIGNAL_7"
#define CHERY_CANFD_HUD_ALERT_ICA_WARNING_NAME "ICA_WARNING"
#define CHERY_CANFD_HUD_ALERT_NEW_SIGNAL_4_NAME "NEW_SIGNAL_4"
#define CHERY_CANFD_HUD_ALERT_STEER_WARNING_NAME "STEER_WARNING"
#define CHERY_CANFD_HUD_ALERT_TAKE_OVER_WARNING_NAME "TAKE_OVER_WARNING"
#define CHERY_CANFD_HUD_ALERT_NEW_SIGNAL_3_NAME "NEW_SIGNAL_3"
#define CHERY_CANFD_HUD_ALERT_NEW_SIGNAL_5_NAME "NEW_SIGNAL_5"
#define CHERY_CANFD_NEW_MSG_40_F_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_NEW_MSG_40_F_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_NEW_MSG_40_F_NEW_SIGNAL_4_NAME "NEW_SIGNAL_4"
#define CHERY_CANFD_NEW_MSG_40_F_NEW_SIGNAL_5_NAME "NEW_SIGNAL_5"
#define CHERY_CANFD_NEW_MSG_40_F_NEW_SIGNAL_6_NAME "NEW_SIGNAL_6"
#define CHERY_CANFD_NEW_MSG_40_F_NEW_SIGNAL_3_NAME "NEW_SIGNAL_3"
#define CHERY_CANFD_NEW_MSG_427_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_NEW_MSG_427_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_NEW_MSG_430_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_NEW_MSG_430_NEW_SIGNAL_9_NAME "NEW_SIGNAL_9"
#define CHERY_CANFD_NEW_MSG_430_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_NEW_MSG_430_NEW_SIGNAL_6_NAME "NEW_SIGNAL_6"
#define CHERY_CANFD_NEW_MSG_430_NEW_SIGNAL_8_NAME "NEW_SIGNAL_8"
#define CHERY_CANFD_NEW_MSG_430_NEW_SIGNAL_7_NAME "NEW_SIGNAL_7"
#define CHERY_CANFD_NEW_MSG_430_NEW_SIGNAL_5_NAME "NEW_SIGNAL_5"
#define CHERY_CANFD_NEW_MSG_430_SEATBELT_NAME "SEATBELT"
#define CHERY_CANFD_NEW_MSG_430_NEW_SIGNAL_4_NAME "NEW_SIGNAL_4"
#define CHERY_CANFD_NEW_MSG_430_NEW_SIGNAL_3_NAME "NEW_SIGNAL_3"
#define CHERY_CANFD_NEW_MSG_435_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_NEW_MSG_45_A_AVM_PRESSED_NAME "AVM_PRESSED"
#define CHERY_CANFD_BSM_LEFT_NEW_SIGNAL_3_NAME "NEW_SIGNAL_3"
#define CHERY_CANFD_BSM_LEFT_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_BSM_LEFT_BSM_LEFT_DETECT_NAME "BSM_LEFT_DETECT"
#define CHERY_CANFD_BSM_RIGHT_BSM_RIGHT_DETECT_NAME "BSM_RIGHT_DETECT"
#define CHERY_CANFD_BSM_RIGHT_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_NEW_MSG_4_DD_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_NEW_MSG_4_DD_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_NEW_MSG_4_E3_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_NEW_MSG_4_E3_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_BRAKE_SENSOR_DRIVE_MODE_NAME "DRIVE_MODE"
#define CHERY_CANFD_BRAKE_SENSOR_EPB_RELEASE_NAME "EPB_RELEASE"
#define CHERY_CANFD_BRAKE_SENSOR_NEW_SIGNAL_3_NAME "NEW_SIGNAL_3"
#define CHERY_CANFD_BRAKE_SENSOR_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_BRAKE_SENSOR_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_BRAKE_SENSOR_BRAKE_PRESS_NAME "BRAKE_PRESS"
#define CHERY_CANFD_BRAKE_SENSOR_NEW_SIGNAL_4_NAME "NEW_SIGNAL_4"
#define CHERY_CANFD_BRAKE_SENSOR_CHARGE_STATUS_NAME "CHARGE_STATUS"
#define CHERY_CANFD_BRAKE_SENSOR_BRAKE_REQUEST_NAME "BRAKE_REQUEST"
#define CHERY_CANFD_CARLINKO_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_CARLINKO_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_EPB_EPB_SIGNAL_NAME "EPB_SIGNAL"
#define CHERY_CANFD_EPB_EPB_ACTIVE_NAME "EPB_ACTIVE"
#define CHERY_CANFD_WINDOW_COMMAND_NEW_SIGNAL_1_NAME "NEW_SIGNAL_1"
#define CHERY_CANFD_AEB_COMMAND_AEB_ACTIVE_NAME "AEB_ACTIVE"
#define CHERY_CANFD_NEW_MSG_51_D_NEW_SIGNAL_2_NAME "NEW_SIGNAL_2"
#define CHERY_CANFD_NEW_MSG_51_D_HDC_ACTIVE_NAME "HDC_ACTIVE"
#define CHERY_CANFD_NEW_MSG_537_TRAKSI_COMMAND_NAME "TRAKSI_COMMAND"
#define CHERY_CANFD_NEW_MSG_537_DRIVE_MODE_NAME "DRIVE_MODE"
#define CHERY_CANFD_NEW_MSG_537_EPB_PRESSED_NAME "EPB_PRESSED"

/**
 * Signals in message ENGINE_DATA.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_engine_data_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t new_signal_4;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_8;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t accel;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;

    /**
     * Range: 600..727 (0..127 -)
     * Scale: 1
     * Offset: -600
     */
    uint16_t gas_pos;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_9;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t new_signal_7;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_13;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t new_signal_6;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t new_signal_15;

    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_11;

    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_12;

    /**
     * Range: 0..327670 (0..32767 -)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t gas;

    /**
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gear;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gear_button;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_press;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cc_state;

    /**
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cruize_speed;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch_to_p;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_3;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t new_signal_14;
};

/**
 * Signals in message STEER_SENSOR.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_steer_sensor_t {
    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t angle;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fraction;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t torque;

    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t torque_driver;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_3;
};

/**
 * Signals in message NEW_MSG_127.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_new_msg_127_t {
    /**
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_4;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_3;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t new_signal_1;
};

/**
 * Signals in message NEW_MSG_128.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_new_msg_128_t {
    /**
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t new_signal_1;
};

/**
 * Signals in message STEER_ANGLE_SENSOR.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_steer_angle_sensor_t {
    /**
     * Range: 7800..171630 (0..16383 -)
     * Scale: 0.1
     * Offset: -780
     */
    uint16_t steer_angle;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t torque;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message LKAS.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_lkas_t {
    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t new_signal_7;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_5;

    /**
     * Range: 0..2047 (0..2047 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t lkas_cmd;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_4;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message NEW_MSG_260.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_new_msg_260_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_6;

    /**
     * Range: 0..1023 (0..1023 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t new_signal_3;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_5;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_press;

    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_4;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;

    /**
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t new_signal_1;
};

/**
 * Signals in message NEW_MSG_287.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_new_msg_287_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t epb_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t seatbelt_lock;
};

/**
 * Signals in message BRAKE_DATA.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_brake_data_t {
    /**
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;

    /**
     * Range: 100..611 (0..511 -)
     * Scale: 1
     * Offset: -100
     */
    int16_t brake_pos;
};

/**
 * Signals in message NEW_MSG_2E9.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_new_msg_2_e9_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message DOOR.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_door_t {
    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;
};

/**
 * Signals in message NEW_MSG_305.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_new_msg_305_t {
    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;
};

/**
 * Signals in message LKAS_STATE.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_lkas_state_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_3;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_4;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t state;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lka_active;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message WHEEL_SPEED_REAR.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_wheel_speed_rear_t {
    /**
     * Range: 0..3957367 (0..32767 -)
     * Scale: 0.00828
     * Offset: 0
     */
    uint16_t wheel_speed_rr;

    /**
     * Range: 0..3957367 (0..32767 -)
     * Scale: 0.00828
     * Offset: 0
     */
    uint16_t wheel_speed_rl;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;
};

/**
 * Signals in message WHEEL_SPEED_FRNT.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_wheel_speed_frnt_t {
    /**
     * Range: -241255..3952593 (-2000..32767 kmh)
     * Scale: 0.00829
     * Offset: 0
     */
    int16_t wheel_speed_fr;

    /**
     * Range: 0..3952593 (0..32767 -)
     * Scale: 0.00829
     * Offset: 0
     */
    int16_t wheel_speed_fl;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t stopped;
};

/**
 * Signals in message NEW_MSG_319.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_new_msg_319_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message LKAS_CAM_CMD_345.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_lkas_cam_cmd_345_t {
    /**
     * Range: 7800..89710 (0..8191 -)
     * Scale: 0.1
     * Offset: -780
     */
    uint16_t cmd;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lka_active;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t set_x0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t new_signal_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_6;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_7;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message STEER_BUTTON.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_steer_button_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t res_plus;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cc_btn;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acc;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t res_minus;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gap_adjust_up;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gap_adjust_down;
};

/**
 * Signals in message SETTING.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_setting_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cancel_alert;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_6;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t show_aeb;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gap;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_3;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acc_available;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acc_active;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aeb_active;

    /**
     * Range: 0..1023 (0..1023 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cc_speed;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message BCM_SIGNAL_2.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_bcm_signal_2_t {
    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_6;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t high_beam;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t left_sign;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t right_sign;

    /**
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t door_lock_open;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_8;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_11;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_3;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_5;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t right_sign_pressed;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t left_sign_pressed;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t wiper_button;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_9;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;
};

/**
 * Signals in message BCM_SIGNAL_1.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_bcm_signal_1_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sign_signal;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t door_lock;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rl_door_open;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rr_door_open;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fl_door_open;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fr_door_open;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_3;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;
};

/**
 * Signals in message STEER_SENSOR_2.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_steer_sensor_2_t {
    /**
     * Range: 0..4262 (0..1023 -)
     * Scale: 0.24
     * Offset: 0
     */
    int16_t torque_driver;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;
};

/**
 * Signals in message ACC_CMD.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_acc_cmd_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t accel_on;

    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t cmd;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acc_state_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t stopped;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acc_state;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t stopping;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_9;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_12;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_6;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_5;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_8;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_13;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_10;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t new_signal_4;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gas_pressed;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_11;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message ACC.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_acc_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_7;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_10;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_8;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_9;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_6;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_11;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_5;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_4;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gas_pressed;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acc_active;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_12;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aeb_active;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message NEW_MSG_3A7.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_new_msg_3_a7_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message NEW_MSG_3AF.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_new_msg_3_af_t {
    /**
     * Range: 0..16383 (0..16383 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t new_signal_3;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_5;

    /**
     * Range: 0..16383 (0..16383 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t new_signal_1;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;

    /**
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t checksum;
};

/**
 * Signals in message NEW_MSG_3DC.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_new_msg_3_dc_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_8;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_6;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_5;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_7;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aeb_maybe;

    /**
     * Range: 0..8191 (0..8191 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t new_signal_4;

    /**
     * Range: 0..8191 (0..8191 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;

    /**
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_3;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t new_signal_2;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message NEW_MSG_3DE.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_new_msg_3_de_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_5;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_6;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_4;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_7;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t new_signal_3;
};

/**
 * Signals in message NEW_MSG_3E2.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_new_msg_3_e2_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;

    /**
     * Range: 0..1023 (0..1023 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t new_signal_1;
};

/**
 * Signals in message LEAD_FRONT.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_lead_front_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_7;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t valid_signal;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_3;

    /**
     * Range: 0..8191 (0..8191 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lead_distance;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_6;

    /**
     * Range: 0..2047 (0..2047 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_9;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_8;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_5;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;
};

/**
 * Signals in message NEW_MSG_3F0.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_new_msg_3_f0_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message LEAD_RIGHT_LEFT.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_lead_right_left_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_3;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_9;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_8;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t valid_signal;

    /**
     * Range: 0..511 (0..511 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lead_left;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_4;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_7;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t valid_signal_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lead_right;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_6;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_5;

    /**
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t new_signal_1;
};

/**
 * Signals in message HUD_ALERT.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_hud_alert_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_6;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_7;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ica_warning;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_4;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t steer_warning;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t take_over_warning;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t new_signal_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_5;
};

/**
 * Signals in message NEW_MSG_40F.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_new_msg_40_f_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_4;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_5;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_6;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_3;
};

/**
 * Signals in message NEW_MSG_427.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_new_msg_427_t {
    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;
};

/**
 * Signals in message NEW_MSG_430.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_new_msg_430_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_9;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;

    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_6;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_8;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_7;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_5;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t seatbelt;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_3;
};

/**
 * Signals in message NEW_MSG_435.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_new_msg_435_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;
};

/**
 * Signals in message NEW_MSG_45A.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_new_msg_45_a_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t avm_pressed;
};

/**
 * Signals in message BSM_LEFT.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_bsm_left_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_3;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bsm_left_detect;
};

/**
 * Signals in message BSM_RIGHT.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_bsm_right_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bsm_right_detect;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;
};

/**
 * Signals in message NEW_MSG_4DD.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_new_msg_4_dd_t {
    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;
};

/**
 * Signals in message NEW_MSG_4E3.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_new_msg_4_e3_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;
};

/**
 * Signals in message BRAKE_SENSOR.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_brake_sensor_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t drive_mode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t epb_release;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_3;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_press;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_4;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t charge_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_request;
};

/**
 * Signals in message carlinko.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_carlinko_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;
};

/**
 * Signals in message EPB.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_epb_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t epb_signal;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t epb_active;
};

/**
 * Signals in message Window_Command.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_window_command_t {
    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;
};

/**
 * Signals in message AEB_COMMAND.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_aeb_command_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aeb_active;
};

/**
 * Signals in message NEW_MSG_51B.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_new_msg_51_b_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message NEW_MSG_51D.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_new_msg_51_d_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hdc_active;
};

/**
 * Signals in message NEW_MSG_535.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_new_msg_535_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message NEW_MSG_537.
 *
 * All signal values are as on the CAN bus.
 */
struct chery_canfd_new_msg_537_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t traksi_command;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t drive_mode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t epb_pressed;
};

/**
 * Pack message ENGINE_DATA.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_engine_data_pack(
    uint8_t *dst_p,
    const struct chery_canfd_engine_data_t *src_p,
    size_t size);

/**
 * Unpack message ENGINE_DATA.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_engine_data_unpack(
    struct chery_canfd_engine_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ENGINE_DATA.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_engine_data_init(struct chery_canfd_engine_data_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_engine_data_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_engine_data_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_engine_data_new_signal_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_engine_data_new_signal_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_engine_data_new_signal_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_engine_data_new_signal_5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t chery_canfd_engine_data_new_signal_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_engine_data_new_signal_4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_engine_data_new_signal_4_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_engine_data_new_signal_8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_engine_data_new_signal_8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_engine_data_new_signal_8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t chery_canfd_engine_data_accel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_engine_data_accel_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_engine_data_accel_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_engine_data_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_engine_data_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_engine_data_new_signal_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t chery_canfd_engine_data_gas_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_engine_data_gas_pos_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_engine_data_gas_pos_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_engine_data_new_signal_9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_engine_data_new_signal_9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_engine_data_new_signal_9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t chery_canfd_engine_data_new_signal_7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_engine_data_new_signal_7_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_engine_data_new_signal_7_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_engine_data_new_signal_13_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_engine_data_new_signal_13_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_engine_data_new_signal_13_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t chery_canfd_engine_data_new_signal_6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_engine_data_new_signal_6_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_engine_data_new_signal_6_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t chery_canfd_engine_data_new_signal_15_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_engine_data_new_signal_15_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_engine_data_new_signal_15_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_engine_data_new_signal_11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_engine_data_new_signal_11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_engine_data_new_signal_11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_engine_data_new_signal_12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_engine_data_new_signal_12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_engine_data_new_signal_12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t chery_canfd_engine_data_gas_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_engine_data_gas_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_engine_data_gas_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_engine_data_gear_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_engine_data_gear_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_engine_data_gear_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_engine_data_gear_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_engine_data_gear_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_engine_data_gear_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_engine_data_brake_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_engine_data_brake_press_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_engine_data_brake_press_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_engine_data_cc_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_engine_data_cc_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_engine_data_cc_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_engine_data_cruize_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_engine_data_cruize_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_engine_data_cruize_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_engine_data_switch_to_p_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_engine_data_switch_to_p_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_engine_data_switch_to_p_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_engine_data_new_signal_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_engine_data_new_signal_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_engine_data_new_signal_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t chery_canfd_engine_data_new_signal_14_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_engine_data_new_signal_14_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_engine_data_new_signal_14_is_in_range(uint16_t value);

/**
 * Pack message STEER_SENSOR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_steer_sensor_pack(
    uint8_t *dst_p,
    const struct chery_canfd_steer_sensor_t *src_p,
    size_t size);

/**
 * Unpack message STEER_SENSOR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_steer_sensor_unpack(
    struct chery_canfd_steer_sensor_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from STEER_SENSOR.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_steer_sensor_init(struct chery_canfd_steer_sensor_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_steer_sensor_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_steer_sensor_angle_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_steer_sensor_angle_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_steer_sensor_fraction_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_steer_sensor_fraction_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_steer_sensor_fraction_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t chery_canfd_steer_sensor_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_steer_sensor_torque_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_steer_sensor_torque_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t chery_canfd_steer_sensor_torque_driver_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_steer_sensor_torque_driver_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_steer_sensor_torque_driver_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_steer_sensor_new_signal_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_steer_sensor_new_signal_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_steer_sensor_new_signal_3_is_in_range(uint8_t value);

/**
 * Pack message NEW_MSG_127.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_new_msg_127_pack(
    uint8_t *dst_p,
    const struct chery_canfd_new_msg_127_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_127.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_new_msg_127_unpack(
    struct chery_canfd_new_msg_127_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NEW_MSG_127.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_new_msg_127_init(struct chery_canfd_new_msg_127_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_127_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_127_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_127_new_signal_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_127_new_signal_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_127_new_signal_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_127_new_signal_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_127_new_signal_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_127_new_signal_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_127_new_signal_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t chery_canfd_new_msg_127_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_127_new_signal_1_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_127_new_signal_1_is_in_range(int8_t value);

/**
 * Pack message NEW_MSG_128.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_new_msg_128_pack(
    uint8_t *dst_p,
    const struct chery_canfd_new_msg_128_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_128.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_new_msg_128_unpack(
    struct chery_canfd_new_msg_128_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NEW_MSG_128.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_new_msg_128_init(struct chery_canfd_new_msg_128_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t chery_canfd_new_msg_128_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_128_new_signal_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_128_new_signal_1_is_in_range(uint16_t value);

/**
 * Pack message STEER_ANGLE_SENSOR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_steer_angle_sensor_pack(
    uint8_t *dst_p,
    const struct chery_canfd_steer_angle_sensor_t *src_p,
    size_t size);

/**
 * Unpack message STEER_ANGLE_SENSOR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_steer_angle_sensor_unpack(
    struct chery_canfd_steer_angle_sensor_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from STEER_ANGLE_SENSOR.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_steer_angle_sensor_init(struct chery_canfd_steer_angle_sensor_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t chery_canfd_steer_angle_sensor_steer_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_steer_angle_sensor_steer_angle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_steer_angle_sensor_steer_angle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t chery_canfd_steer_angle_sensor_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_steer_angle_sensor_torque_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_steer_angle_sensor_torque_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_steer_angle_sensor_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_steer_angle_sensor_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_steer_angle_sensor_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_steer_angle_sensor_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_steer_angle_sensor_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_steer_angle_sensor_checksum_is_in_range(uint8_t value);

/**
 * Pack message LKAS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_lkas_pack(
    uint8_t *dst_p,
    const struct chery_canfd_lkas_t *src_p,
    size_t size);

/**
 * Unpack message LKAS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_lkas_unpack(
    struct chery_canfd_lkas_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from LKAS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_lkas_init(struct chery_canfd_lkas_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lkas_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lkas_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lkas_new_signal_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t chery_canfd_lkas_new_signal_7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lkas_new_signal_7_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lkas_new_signal_7_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lkas_new_signal_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lkas_new_signal_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lkas_new_signal_5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t chery_canfd_lkas_lkas_cmd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lkas_lkas_cmd_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lkas_lkas_cmd_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lkas_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lkas_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lkas_new_signal_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lkas_new_signal_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lkas_new_signal_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lkas_new_signal_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lkas_new_signal_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lkas_new_signal_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lkas_new_signal_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lkas_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lkas_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lkas_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lkas_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lkas_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lkas_checksum_is_in_range(uint8_t value);

/**
 * Pack message NEW_MSG_260.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_new_msg_260_pack(
    uint8_t *dst_p,
    const struct chery_canfd_new_msg_260_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_260.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_new_msg_260_unpack(
    struct chery_canfd_new_msg_260_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NEW_MSG_260.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_new_msg_260_init(struct chery_canfd_new_msg_260_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_260_new_signal_6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_260_new_signal_6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_260_new_signal_6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t chery_canfd_new_msg_260_new_signal_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_260_new_signal_3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_260_new_signal_3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_260_new_signal_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_260_new_signal_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_260_new_signal_5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_260_brake_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_260_brake_press_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_260_brake_press_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_260_new_signal_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_260_new_signal_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_260_new_signal_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_260_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_260_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_260_new_signal_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t chery_canfd_new_msg_260_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_260_new_signal_1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_260_new_signal_1_is_in_range(int16_t value);

/**
 * Pack message NEW_MSG_287.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_new_msg_287_pack(
    uint8_t *dst_p,
    const struct chery_canfd_new_msg_287_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_287.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_new_msg_287_unpack(
    struct chery_canfd_new_msg_287_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NEW_MSG_287.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_new_msg_287_init(struct chery_canfd_new_msg_287_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_287_epb_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_287_epb_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_287_epb_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_287_seatbelt_lock_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_287_seatbelt_lock_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_287_seatbelt_lock_is_in_range(uint8_t value);

/**
 * Pack message BRAKE_DATA.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_brake_data_pack(
    uint8_t *dst_p,
    const struct chery_canfd_brake_data_t *src_p,
    size_t size);

/**
 * Unpack message BRAKE_DATA.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_brake_data_unpack(
    struct chery_canfd_brake_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BRAKE_DATA.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_brake_data_init(struct chery_canfd_brake_data_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_brake_data_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_brake_data_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_brake_data_new_signal_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t chery_canfd_brake_data_brake_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_brake_data_brake_pos_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_brake_data_brake_pos_is_in_range(int16_t value);

/**
 * Pack message NEW_MSG_2E9.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_new_msg_2_e9_pack(
    uint8_t *dst_p,
    const struct chery_canfd_new_msg_2_e9_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_2E9.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_new_msg_2_e9_unpack(
    struct chery_canfd_new_msg_2_e9_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NEW_MSG_2E9.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_new_msg_2_e9_init(struct chery_canfd_new_msg_2_e9_t *msg_p);

/**
 * Pack message DOOR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_door_pack(
    uint8_t *dst_p,
    const struct chery_canfd_door_t *src_p,
    size_t size);

/**
 * Unpack message DOOR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_door_unpack(
    struct chery_canfd_door_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DOOR.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_door_init(struct chery_canfd_door_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_door_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_door_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_door_new_signal_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_door_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_door_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_door_new_signal_1_is_in_range(uint8_t value);

/**
 * Pack message NEW_MSG_305.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_new_msg_305_pack(
    uint8_t *dst_p,
    const struct chery_canfd_new_msg_305_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_305.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_new_msg_305_unpack(
    struct chery_canfd_new_msg_305_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NEW_MSG_305.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_new_msg_305_init(struct chery_canfd_new_msg_305_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_305_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_305_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_305_new_signal_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_305_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_305_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_305_new_signal_1_is_in_range(uint8_t value);

/**
 * Pack message LKAS_STATE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_lkas_state_pack(
    uint8_t *dst_p,
    const struct chery_canfd_lkas_state_t *src_p,
    size_t size);

/**
 * Unpack message LKAS_STATE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_lkas_state_unpack(
    struct chery_canfd_lkas_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from LKAS_STATE.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_lkas_state_init(struct chery_canfd_lkas_state_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lkas_state_new_signal_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lkas_state_new_signal_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lkas_state_new_signal_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lkas_state_new_signal_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lkas_state_new_signal_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lkas_state_new_signal_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lkas_state_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lkas_state_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lkas_state_new_signal_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lkas_state_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lkas_state_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lkas_state_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lkas_state_lka_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lkas_state_lka_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lkas_state_lka_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lkas_state_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lkas_state_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lkas_state_new_signal_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lkas_state_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lkas_state_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lkas_state_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lkas_state_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lkas_state_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lkas_state_checksum_is_in_range(uint8_t value);

/**
 * Pack message WHEEL_SPEED_REAR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_wheel_speed_rear_pack(
    uint8_t *dst_p,
    const struct chery_canfd_wheel_speed_rear_t *src_p,
    size_t size);

/**
 * Unpack message WHEEL_SPEED_REAR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_wheel_speed_rear_unpack(
    struct chery_canfd_wheel_speed_rear_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from WHEEL_SPEED_REAR.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_wheel_speed_rear_init(struct chery_canfd_wheel_speed_rear_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t chery_canfd_wheel_speed_rear_wheel_speed_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_wheel_speed_rear_wheel_speed_rr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_wheel_speed_rear_wheel_speed_rr_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t chery_canfd_wheel_speed_rear_wheel_speed_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_wheel_speed_rear_wheel_speed_rl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_wheel_speed_rear_wheel_speed_rl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_wheel_speed_rear_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_wheel_speed_rear_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_wheel_speed_rear_new_signal_1_is_in_range(uint8_t value);

/**
 * Pack message WHEEL_SPEED_FRNT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_wheel_speed_frnt_pack(
    uint8_t *dst_p,
    const struct chery_canfd_wheel_speed_frnt_t *src_p,
    size_t size);

/**
 * Unpack message WHEEL_SPEED_FRNT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_wheel_speed_frnt_unpack(
    struct chery_canfd_wheel_speed_frnt_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from WHEEL_SPEED_FRNT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_wheel_speed_frnt_init(struct chery_canfd_wheel_speed_frnt_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t chery_canfd_wheel_speed_frnt_wheel_speed_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_wheel_speed_frnt_wheel_speed_fr_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_wheel_speed_frnt_wheel_speed_fr_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t chery_canfd_wheel_speed_frnt_wheel_speed_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_wheel_speed_frnt_wheel_speed_fl_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_wheel_speed_frnt_wheel_speed_fl_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_wheel_speed_frnt_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_wheel_speed_frnt_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_wheel_speed_frnt_new_signal_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_wheel_speed_frnt_stopped_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_wheel_speed_frnt_stopped_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_wheel_speed_frnt_stopped_is_in_range(uint8_t value);

/**
 * Pack message NEW_MSG_319.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_new_msg_319_pack(
    uint8_t *dst_p,
    const struct chery_canfd_new_msg_319_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_319.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_new_msg_319_unpack(
    struct chery_canfd_new_msg_319_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NEW_MSG_319.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_new_msg_319_init(struct chery_canfd_new_msg_319_t *msg_p);

/**
 * Pack message LKAS_CAM_CMD_345.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_lkas_cam_cmd_345_pack(
    uint8_t *dst_p,
    const struct chery_canfd_lkas_cam_cmd_345_t *src_p,
    size_t size);

/**
 * Unpack message LKAS_CAM_CMD_345.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_lkas_cam_cmd_345_unpack(
    struct chery_canfd_lkas_cam_cmd_345_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from LKAS_CAM_CMD_345.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_lkas_cam_cmd_345_init(struct chery_canfd_lkas_cam_cmd_345_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t chery_canfd_lkas_cam_cmd_345_cmd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lkas_cam_cmd_345_cmd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lkas_cam_cmd_345_cmd_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lkas_cam_cmd_345_lka_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lkas_cam_cmd_345_lka_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lkas_cam_cmd_345_lka_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lkas_cam_cmd_345_set_x0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lkas_cam_cmd_345_set_x0_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lkas_cam_cmd_345_set_x0_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t chery_canfd_lkas_cam_cmd_345_new_signal_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lkas_cam_cmd_345_new_signal_5_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lkas_cam_cmd_345_new_signal_5_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lkas_cam_cmd_345_new_signal_6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lkas_cam_cmd_345_new_signal_6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lkas_cam_cmd_345_new_signal_6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lkas_cam_cmd_345_new_signal_7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lkas_cam_cmd_345_new_signal_7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lkas_cam_cmd_345_new_signal_7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lkas_cam_cmd_345_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lkas_cam_cmd_345_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lkas_cam_cmd_345_new_signal_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lkas_cam_cmd_345_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lkas_cam_cmd_345_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lkas_cam_cmd_345_checksum_is_in_range(uint8_t value);

/**
 * Pack message STEER_BUTTON.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_steer_button_pack(
    uint8_t *dst_p,
    const struct chery_canfd_steer_button_t *src_p,
    size_t size);

/**
 * Unpack message STEER_BUTTON.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_steer_button_unpack(
    struct chery_canfd_steer_button_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from STEER_BUTTON.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_steer_button_init(struct chery_canfd_steer_button_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_steer_button_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_steer_button_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_steer_button_checksum_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_steer_button_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_steer_button_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_steer_button_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_steer_button_res_plus_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_steer_button_res_plus_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_steer_button_res_plus_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_steer_button_cc_btn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_steer_button_cc_btn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_steer_button_cc_btn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_steer_button_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_steer_button_acc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_steer_button_acc_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_steer_button_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_steer_button_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_steer_button_new_signal_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_steer_button_res_minus_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_steer_button_res_minus_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_steer_button_res_minus_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_steer_button_gap_adjust_up_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_steer_button_gap_adjust_up_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_steer_button_gap_adjust_up_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_steer_button_gap_adjust_down_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_steer_button_gap_adjust_down_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_steer_button_gap_adjust_down_is_in_range(uint8_t value);

/**
 * Pack message SETTING.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_setting_pack(
    uint8_t *dst_p,
    const struct chery_canfd_setting_t *src_p,
    size_t size);

/**
 * Unpack message SETTING.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_setting_unpack(
    struct chery_canfd_setting_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SETTING.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_setting_init(struct chery_canfd_setting_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_setting_cancel_alert_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_setting_cancel_alert_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_setting_cancel_alert_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_setting_new_signal_6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_setting_new_signal_6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_setting_new_signal_6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_setting_show_aeb_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_setting_show_aeb_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_setting_show_aeb_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_setting_gap_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_setting_gap_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_setting_gap_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_setting_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_setting_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_setting_new_signal_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_setting_new_signal_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_setting_new_signal_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_setting_new_signal_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_setting_acc_available_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_setting_acc_available_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_setting_acc_available_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_setting_acc_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_setting_acc_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_setting_acc_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_setting_aeb_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_setting_aeb_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_setting_aeb_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_setting_cc_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_setting_cc_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_setting_cc_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_setting_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_setting_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_setting_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_setting_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_setting_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_setting_checksum_is_in_range(uint8_t value);

/**
 * Pack message BCM_SIGNAL_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_bcm_signal_2_pack(
    uint8_t *dst_p,
    const struct chery_canfd_bcm_signal_2_t *src_p,
    size_t size);

/**
 * Unpack message BCM_SIGNAL_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_bcm_signal_2_unpack(
    struct chery_canfd_bcm_signal_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BCM_SIGNAL_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_bcm_signal_2_init(struct chery_canfd_bcm_signal_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bcm_signal_2_new_signal_6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bcm_signal_2_new_signal_6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bcm_signal_2_new_signal_6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bcm_signal_2_high_beam_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bcm_signal_2_high_beam_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bcm_signal_2_high_beam_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bcm_signal_2_left_sign_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bcm_signal_2_left_sign_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bcm_signal_2_left_sign_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bcm_signal_2_right_sign_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bcm_signal_2_right_sign_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bcm_signal_2_right_sign_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bcm_signal_2_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bcm_signal_2_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bcm_signal_2_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bcm_signal_2_door_lock_open_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bcm_signal_2_door_lock_open_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bcm_signal_2_door_lock_open_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bcm_signal_2_new_signal_8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bcm_signal_2_new_signal_8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bcm_signal_2_new_signal_8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bcm_signal_2_new_signal_11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bcm_signal_2_new_signal_11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bcm_signal_2_new_signal_11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bcm_signal_2_new_signal_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bcm_signal_2_new_signal_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bcm_signal_2_new_signal_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bcm_signal_2_new_signal_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bcm_signal_2_new_signal_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bcm_signal_2_new_signal_5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bcm_signal_2_right_sign_pressed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bcm_signal_2_right_sign_pressed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bcm_signal_2_right_sign_pressed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bcm_signal_2_left_sign_pressed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bcm_signal_2_left_sign_pressed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bcm_signal_2_left_sign_pressed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bcm_signal_2_wiper_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bcm_signal_2_wiper_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bcm_signal_2_wiper_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bcm_signal_2_new_signal_9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bcm_signal_2_new_signal_9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bcm_signal_2_new_signal_9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bcm_signal_2_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bcm_signal_2_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bcm_signal_2_new_signal_2_is_in_range(uint8_t value);

/**
 * Pack message BCM_SIGNAL_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_bcm_signal_1_pack(
    uint8_t *dst_p,
    const struct chery_canfd_bcm_signal_1_t *src_p,
    size_t size);

/**
 * Unpack message BCM_SIGNAL_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_bcm_signal_1_unpack(
    struct chery_canfd_bcm_signal_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BCM_SIGNAL_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_bcm_signal_1_init(struct chery_canfd_bcm_signal_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bcm_signal_1_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bcm_signal_1_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bcm_signal_1_new_signal_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bcm_signal_1_sign_signal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bcm_signal_1_sign_signal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bcm_signal_1_sign_signal_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bcm_signal_1_door_lock_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bcm_signal_1_door_lock_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bcm_signal_1_door_lock_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bcm_signal_1_rl_door_open_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bcm_signal_1_rl_door_open_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bcm_signal_1_rl_door_open_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bcm_signal_1_rr_door_open_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bcm_signal_1_rr_door_open_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bcm_signal_1_rr_door_open_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bcm_signal_1_fl_door_open_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bcm_signal_1_fl_door_open_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bcm_signal_1_fl_door_open_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bcm_signal_1_fr_door_open_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bcm_signal_1_fr_door_open_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bcm_signal_1_fr_door_open_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bcm_signal_1_new_signal_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bcm_signal_1_new_signal_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bcm_signal_1_new_signal_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bcm_signal_1_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bcm_signal_1_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bcm_signal_1_new_signal_1_is_in_range(uint8_t value);

/**
 * Pack message STEER_SENSOR_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_steer_sensor_2_pack(
    uint8_t *dst_p,
    const struct chery_canfd_steer_sensor_2_t *src_p,
    size_t size);

/**
 * Unpack message STEER_SENSOR_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_steer_sensor_2_unpack(
    struct chery_canfd_steer_sensor_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from STEER_SENSOR_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_steer_sensor_2_init(struct chery_canfd_steer_sensor_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t chery_canfd_steer_sensor_2_torque_driver_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_steer_sensor_2_torque_driver_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_steer_sensor_2_torque_driver_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_steer_sensor_2_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_steer_sensor_2_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_steer_sensor_2_new_signal_1_is_in_range(uint8_t value);

/**
 * Pack message ACC_CMD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_acc_cmd_pack(
    uint8_t *dst_p,
    const struct chery_canfd_acc_cmd_t *src_p,
    size_t size);

/**
 * Unpack message ACC_CMD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_acc_cmd_unpack(
    struct chery_canfd_acc_cmd_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ACC_CMD.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_acc_cmd_init(struct chery_canfd_acc_cmd_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_cmd_accel_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_cmd_accel_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_cmd_accel_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t chery_canfd_acc_cmd_cmd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_cmd_cmd_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_cmd_cmd_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_cmd_acc_state_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_cmd_acc_state_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_cmd_acc_state_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_cmd_stopped_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_cmd_stopped_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_cmd_stopped_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_cmd_acc_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_cmd_acc_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_cmd_acc_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_cmd_stopping_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_cmd_stopping_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_cmd_stopping_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_cmd_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_cmd_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_cmd_new_signal_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_cmd_new_signal_9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_cmd_new_signal_9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_cmd_new_signal_9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_cmd_new_signal_12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_cmd_new_signal_12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_cmd_new_signal_12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_cmd_new_signal_6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_cmd_new_signal_6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_cmd_new_signal_6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_cmd_new_signal_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_cmd_new_signal_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_cmd_new_signal_5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_cmd_new_signal_8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_cmd_new_signal_8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_cmd_new_signal_8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_cmd_new_signal_13_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_cmd_new_signal_13_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_cmd_new_signal_13_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_cmd_new_signal_10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_cmd_new_signal_10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_cmd_new_signal_10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_cmd_new_signal_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_cmd_new_signal_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_cmd_new_signal_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t chery_canfd_acc_cmd_new_signal_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_cmd_new_signal_4_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_cmd_new_signal_4_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_cmd_gas_pressed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_cmd_gas_pressed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_cmd_gas_pressed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_cmd_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_cmd_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_cmd_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_cmd_new_signal_11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_cmd_new_signal_11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_cmd_new_signal_11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_cmd_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_cmd_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_cmd_checksum_is_in_range(uint8_t value);

/**
 * Pack message ACC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_acc_pack(
    uint8_t *dst_p,
    const struct chery_canfd_acc_t *src_p,
    size_t size);

/**
 * Unpack message ACC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_acc_unpack(
    struct chery_canfd_acc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ACC.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_acc_init(struct chery_canfd_acc_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_new_signal_7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_new_signal_7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_new_signal_7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_new_signal_10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_new_signal_10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_new_signal_10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_new_signal_8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_new_signal_8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_new_signal_8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_new_signal_9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_new_signal_9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_new_signal_9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_new_signal_6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_new_signal_6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_new_signal_6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_new_signal_11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_new_signal_11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_new_signal_11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_new_signal_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_new_signal_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_new_signal_5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_new_signal_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_new_signal_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_new_signal_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_gas_pressed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_gas_pressed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_gas_pressed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_acc_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_acc_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_acc_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_new_signal_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_new_signal_12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_new_signal_12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_new_signal_12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_aeb_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_aeb_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_aeb_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_new_signal_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_acc_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_acc_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_acc_checksum_is_in_range(uint8_t value);

/**
 * Pack message NEW_MSG_3A7.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_new_msg_3_a7_pack(
    uint8_t *dst_p,
    const struct chery_canfd_new_msg_3_a7_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_3A7.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_new_msg_3_a7_unpack(
    struct chery_canfd_new_msg_3_a7_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NEW_MSG_3A7.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_new_msg_3_a7_init(struct chery_canfd_new_msg_3_a7_t *msg_p);

/**
 * Pack message NEW_MSG_3AF.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_new_msg_3_af_pack(
    uint8_t *dst_p,
    const struct chery_canfd_new_msg_3_af_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_3AF.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_new_msg_3_af_unpack(
    struct chery_canfd_new_msg_3_af_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NEW_MSG_3AF.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_new_msg_3_af_init(struct chery_canfd_new_msg_3_af_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t chery_canfd_new_msg_3_af_new_signal_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_3_af_new_signal_3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_3_af_new_signal_3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_3_af_new_signal_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_3_af_new_signal_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_3_af_new_signal_5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t chery_canfd_new_msg_3_af_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_3_af_new_signal_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_3_af_new_signal_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_3_af_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_3_af_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_3_af_new_signal_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t chery_canfd_new_msg_3_af_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_3_af_checksum_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_3_af_checksum_is_in_range(uint16_t value);

/**
 * Pack message NEW_MSG_3DC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_new_msg_3_dc_pack(
    uint8_t *dst_p,
    const struct chery_canfd_new_msg_3_dc_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_3DC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_new_msg_3_dc_unpack(
    struct chery_canfd_new_msg_3_dc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NEW_MSG_3DC.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_new_msg_3_dc_init(struct chery_canfd_new_msg_3_dc_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_3_dc_new_signal_8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_3_dc_new_signal_8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_3_dc_new_signal_8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_3_dc_new_signal_6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_3_dc_new_signal_6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_3_dc_new_signal_6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_3_dc_new_signal_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_3_dc_new_signal_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_3_dc_new_signal_5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_3_dc_new_signal_7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_3_dc_new_signal_7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_3_dc_new_signal_7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_3_dc_aeb_maybe_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_3_dc_aeb_maybe_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_3_dc_aeb_maybe_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t chery_canfd_new_msg_3_dc_new_signal_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_3_dc_new_signal_4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_3_dc_new_signal_4_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_3_dc_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_3_dc_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_3_dc_new_signal_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_3_dc_new_signal_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_3_dc_new_signal_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_3_dc_new_signal_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t chery_canfd_new_msg_3_dc_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_3_dc_new_signal_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_3_dc_new_signal_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_3_dc_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_3_dc_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_3_dc_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_3_dc_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_3_dc_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_3_dc_checksum_is_in_range(uint8_t value);

/**
 * Pack message NEW_MSG_3DE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_new_msg_3_de_pack(
    uint8_t *dst_p,
    const struct chery_canfd_new_msg_3_de_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_3DE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_new_msg_3_de_unpack(
    struct chery_canfd_new_msg_3_de_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NEW_MSG_3DE.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_new_msg_3_de_init(struct chery_canfd_new_msg_3_de_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_3_de_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_3_de_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_3_de_new_signal_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_3_de_new_signal_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_3_de_new_signal_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_3_de_new_signal_5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_3_de_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_3_de_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_3_de_new_signal_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_3_de_new_signal_6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_3_de_new_signal_6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_3_de_new_signal_6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_3_de_new_signal_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_3_de_new_signal_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_3_de_new_signal_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_3_de_new_signal_7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_3_de_new_signal_7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_3_de_new_signal_7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t chery_canfd_new_msg_3_de_new_signal_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_3_de_new_signal_3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_3_de_new_signal_3_is_in_range(uint16_t value);

/**
 * Pack message NEW_MSG_3E2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_new_msg_3_e2_pack(
    uint8_t *dst_p,
    const struct chery_canfd_new_msg_3_e2_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_3E2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_new_msg_3_e2_unpack(
    struct chery_canfd_new_msg_3_e2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NEW_MSG_3E2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_new_msg_3_e2_init(struct chery_canfd_new_msg_3_e2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_3_e2_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_3_e2_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_3_e2_new_signal_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t chery_canfd_new_msg_3_e2_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_3_e2_new_signal_1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_3_e2_new_signal_1_is_in_range(int16_t value);

/**
 * Pack message LEAD_FRONT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_lead_front_pack(
    uint8_t *dst_p,
    const struct chery_canfd_lead_front_t *src_p,
    size_t size);

/**
 * Unpack message LEAD_FRONT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_lead_front_unpack(
    struct chery_canfd_lead_front_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from LEAD_FRONT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_lead_front_init(struct chery_canfd_lead_front_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lead_front_new_signal_7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lead_front_new_signal_7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lead_front_new_signal_7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lead_front_valid_signal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lead_front_valid_signal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lead_front_valid_signal_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lead_front_new_signal_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lead_front_new_signal_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lead_front_new_signal_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lead_front_lead_distance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lead_front_lead_distance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lead_front_lead_distance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lead_front_new_signal_6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lead_front_new_signal_6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lead_front_new_signal_6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lead_front_new_signal_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lead_front_new_signal_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lead_front_new_signal_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lead_front_new_signal_9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lead_front_new_signal_9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lead_front_new_signal_9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lead_front_new_signal_8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lead_front_new_signal_8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lead_front_new_signal_8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lead_front_new_signal_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lead_front_new_signal_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lead_front_new_signal_5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lead_front_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lead_front_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lead_front_new_signal_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lead_front_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lead_front_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lead_front_new_signal_1_is_in_range(uint8_t value);

/**
 * Pack message NEW_MSG_3F0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_new_msg_3_f0_pack(
    uint8_t *dst_p,
    const struct chery_canfd_new_msg_3_f0_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_3F0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_new_msg_3_f0_unpack(
    struct chery_canfd_new_msg_3_f0_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NEW_MSG_3F0.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_new_msg_3_f0_init(struct chery_canfd_new_msg_3_f0_t *msg_p);

/**
 * Pack message LEAD_RIGHT_LEFT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_lead_right_left_pack(
    uint8_t *dst_p,
    const struct chery_canfd_lead_right_left_t *src_p,
    size_t size);

/**
 * Unpack message LEAD_RIGHT_LEFT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_lead_right_left_unpack(
    struct chery_canfd_lead_right_left_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from LEAD_RIGHT_LEFT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_lead_right_left_init(struct chery_canfd_lead_right_left_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lead_right_left_new_signal_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lead_right_left_new_signal_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lead_right_left_new_signal_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lead_right_left_new_signal_9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lead_right_left_new_signal_9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lead_right_left_new_signal_9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lead_right_left_new_signal_8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lead_right_left_new_signal_8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lead_right_left_new_signal_8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lead_right_left_valid_signal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lead_right_left_valid_signal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lead_right_left_valid_signal_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lead_right_left_lead_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lead_right_left_lead_left_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lead_right_left_lead_left_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lead_right_left_new_signal_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lead_right_left_new_signal_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lead_right_left_new_signal_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lead_right_left_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lead_right_left_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lead_right_left_new_signal_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lead_right_left_new_signal_7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lead_right_left_new_signal_7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lead_right_left_new_signal_7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lead_right_left_valid_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lead_right_left_valid_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lead_right_left_valid_signal_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lead_right_left_lead_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lead_right_left_lead_right_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lead_right_left_lead_right_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lead_right_left_new_signal_6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lead_right_left_new_signal_6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lead_right_left_new_signal_6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_lead_right_left_new_signal_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lead_right_left_new_signal_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lead_right_left_new_signal_5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t chery_canfd_lead_right_left_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_lead_right_left_new_signal_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_lead_right_left_new_signal_1_is_in_range(uint16_t value);

/**
 * Pack message HUD_ALERT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_hud_alert_pack(
    uint8_t *dst_p,
    const struct chery_canfd_hud_alert_t *src_p,
    size_t size);

/**
 * Unpack message HUD_ALERT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_hud_alert_unpack(
    struct chery_canfd_hud_alert_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from HUD_ALERT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_hud_alert_init(struct chery_canfd_hud_alert_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_hud_alert_new_signal_6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_hud_alert_new_signal_6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_hud_alert_new_signal_6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_hud_alert_new_signal_7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_hud_alert_new_signal_7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_hud_alert_new_signal_7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_hud_alert_ica_warning_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_hud_alert_ica_warning_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_hud_alert_ica_warning_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_hud_alert_new_signal_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_hud_alert_new_signal_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_hud_alert_new_signal_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_hud_alert_steer_warning_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_hud_alert_steer_warning_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_hud_alert_steer_warning_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_hud_alert_take_over_warning_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_hud_alert_take_over_warning_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_hud_alert_take_over_warning_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t chery_canfd_hud_alert_new_signal_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_hud_alert_new_signal_3_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_hud_alert_new_signal_3_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_hud_alert_new_signal_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_hud_alert_new_signal_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_hud_alert_new_signal_5_is_in_range(uint8_t value);

/**
 * Pack message NEW_MSG_40F.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_new_msg_40_f_pack(
    uint8_t *dst_p,
    const struct chery_canfd_new_msg_40_f_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_40F.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_new_msg_40_f_unpack(
    struct chery_canfd_new_msg_40_f_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NEW_MSG_40F.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_new_msg_40_f_init(struct chery_canfd_new_msg_40_f_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_40_f_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_40_f_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_40_f_new_signal_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_40_f_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_40_f_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_40_f_new_signal_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_40_f_new_signal_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_40_f_new_signal_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_40_f_new_signal_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_40_f_new_signal_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_40_f_new_signal_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_40_f_new_signal_5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_40_f_new_signal_6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_40_f_new_signal_6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_40_f_new_signal_6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_40_f_new_signal_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_40_f_new_signal_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_40_f_new_signal_3_is_in_range(uint8_t value);

/**
 * Pack message NEW_MSG_427.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_new_msg_427_pack(
    uint8_t *dst_p,
    const struct chery_canfd_new_msg_427_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_427.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_new_msg_427_unpack(
    struct chery_canfd_new_msg_427_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NEW_MSG_427.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_new_msg_427_init(struct chery_canfd_new_msg_427_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_427_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_427_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_427_new_signal_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_427_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_427_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_427_new_signal_2_is_in_range(uint8_t value);

/**
 * Pack message NEW_MSG_430.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_new_msg_430_pack(
    uint8_t *dst_p,
    const struct chery_canfd_new_msg_430_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_430.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_new_msg_430_unpack(
    struct chery_canfd_new_msg_430_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NEW_MSG_430.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_new_msg_430_init(struct chery_canfd_new_msg_430_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_430_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_430_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_430_new_signal_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_430_new_signal_9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_430_new_signal_9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_430_new_signal_9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_430_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_430_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_430_new_signal_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_430_new_signal_6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_430_new_signal_6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_430_new_signal_6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_430_new_signal_8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_430_new_signal_8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_430_new_signal_8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_430_new_signal_7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_430_new_signal_7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_430_new_signal_7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_430_new_signal_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_430_new_signal_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_430_new_signal_5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_430_seatbelt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_430_seatbelt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_430_seatbelt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_430_new_signal_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_430_new_signal_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_430_new_signal_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_430_new_signal_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_430_new_signal_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_430_new_signal_3_is_in_range(uint8_t value);

/**
 * Pack message NEW_MSG_435.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_new_msg_435_pack(
    uint8_t *dst_p,
    const struct chery_canfd_new_msg_435_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_435.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_new_msg_435_unpack(
    struct chery_canfd_new_msg_435_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NEW_MSG_435.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_new_msg_435_init(struct chery_canfd_new_msg_435_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_435_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_435_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_435_new_signal_1_is_in_range(uint8_t value);

/**
 * Pack message NEW_MSG_45A.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_new_msg_45_a_pack(
    uint8_t *dst_p,
    const struct chery_canfd_new_msg_45_a_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_45A.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_new_msg_45_a_unpack(
    struct chery_canfd_new_msg_45_a_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NEW_MSG_45A.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_new_msg_45_a_init(struct chery_canfd_new_msg_45_a_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_45_a_avm_pressed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_45_a_avm_pressed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_45_a_avm_pressed_is_in_range(uint8_t value);

/**
 * Pack message BSM_LEFT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_bsm_left_pack(
    uint8_t *dst_p,
    const struct chery_canfd_bsm_left_t *src_p,
    size_t size);

/**
 * Unpack message BSM_LEFT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_bsm_left_unpack(
    struct chery_canfd_bsm_left_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BSM_LEFT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_bsm_left_init(struct chery_canfd_bsm_left_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bsm_left_new_signal_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bsm_left_new_signal_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bsm_left_new_signal_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bsm_left_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bsm_left_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bsm_left_new_signal_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bsm_left_bsm_left_detect_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bsm_left_bsm_left_detect_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bsm_left_bsm_left_detect_is_in_range(uint8_t value);

/**
 * Pack message BSM_RIGHT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_bsm_right_pack(
    uint8_t *dst_p,
    const struct chery_canfd_bsm_right_t *src_p,
    size_t size);

/**
 * Unpack message BSM_RIGHT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_bsm_right_unpack(
    struct chery_canfd_bsm_right_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BSM_RIGHT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_bsm_right_init(struct chery_canfd_bsm_right_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bsm_right_bsm_right_detect_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bsm_right_bsm_right_detect_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bsm_right_bsm_right_detect_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_bsm_right_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_bsm_right_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_bsm_right_new_signal_1_is_in_range(uint8_t value);

/**
 * Pack message NEW_MSG_4DD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_new_msg_4_dd_pack(
    uint8_t *dst_p,
    const struct chery_canfd_new_msg_4_dd_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_4DD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_new_msg_4_dd_unpack(
    struct chery_canfd_new_msg_4_dd_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NEW_MSG_4DD.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_new_msg_4_dd_init(struct chery_canfd_new_msg_4_dd_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_4_dd_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_4_dd_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_4_dd_new_signal_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_4_dd_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_4_dd_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_4_dd_new_signal_1_is_in_range(uint8_t value);

/**
 * Pack message NEW_MSG_4E3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_new_msg_4_e3_pack(
    uint8_t *dst_p,
    const struct chery_canfd_new_msg_4_e3_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_4E3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_new_msg_4_e3_unpack(
    struct chery_canfd_new_msg_4_e3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NEW_MSG_4E3.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_new_msg_4_e3_init(struct chery_canfd_new_msg_4_e3_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_4_e3_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_4_e3_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_4_e3_new_signal_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_4_e3_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_4_e3_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_4_e3_new_signal_2_is_in_range(uint8_t value);

/**
 * Pack message BRAKE_SENSOR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_brake_sensor_pack(
    uint8_t *dst_p,
    const struct chery_canfd_brake_sensor_t *src_p,
    size_t size);

/**
 * Unpack message BRAKE_SENSOR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_brake_sensor_unpack(
    struct chery_canfd_brake_sensor_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BRAKE_SENSOR.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_brake_sensor_init(struct chery_canfd_brake_sensor_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_brake_sensor_drive_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_brake_sensor_drive_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_brake_sensor_drive_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_brake_sensor_epb_release_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_brake_sensor_epb_release_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_brake_sensor_epb_release_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_brake_sensor_new_signal_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_brake_sensor_new_signal_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_brake_sensor_new_signal_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_brake_sensor_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_brake_sensor_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_brake_sensor_new_signal_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_brake_sensor_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_brake_sensor_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_brake_sensor_new_signal_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_brake_sensor_brake_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_brake_sensor_brake_press_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_brake_sensor_brake_press_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_brake_sensor_new_signal_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_brake_sensor_new_signal_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_brake_sensor_new_signal_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_brake_sensor_charge_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_brake_sensor_charge_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_brake_sensor_charge_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_brake_sensor_brake_request_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_brake_sensor_brake_request_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_brake_sensor_brake_request_is_in_range(uint8_t value);

/**
 * Pack message carlinko.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_carlinko_pack(
    uint8_t *dst_p,
    const struct chery_canfd_carlinko_t *src_p,
    size_t size);

/**
 * Unpack message carlinko.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_carlinko_unpack(
    struct chery_canfd_carlinko_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from carlinko.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_carlinko_init(struct chery_canfd_carlinko_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_carlinko_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_carlinko_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_carlinko_new_signal_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_carlinko_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_carlinko_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_carlinko_new_signal_2_is_in_range(uint8_t value);

/**
 * Pack message EPB.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_epb_pack(
    uint8_t *dst_p,
    const struct chery_canfd_epb_t *src_p,
    size_t size);

/**
 * Unpack message EPB.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_epb_unpack(
    struct chery_canfd_epb_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EPB.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_epb_init(struct chery_canfd_epb_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_epb_epb_signal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_epb_epb_signal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_epb_epb_signal_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_epb_epb_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_epb_epb_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_epb_epb_active_is_in_range(uint8_t value);

/**
 * Pack message Window_Command.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_window_command_pack(
    uint8_t *dst_p,
    const struct chery_canfd_window_command_t *src_p,
    size_t size);

/**
 * Unpack message Window_Command.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_window_command_unpack(
    struct chery_canfd_window_command_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Window_Command.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_window_command_init(struct chery_canfd_window_command_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_window_command_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_window_command_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_window_command_new_signal_1_is_in_range(uint8_t value);

/**
 * Pack message AEB_COMMAND.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_aeb_command_pack(
    uint8_t *dst_p,
    const struct chery_canfd_aeb_command_t *src_p,
    size_t size);

/**
 * Unpack message AEB_COMMAND.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_aeb_command_unpack(
    struct chery_canfd_aeb_command_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AEB_COMMAND.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_aeb_command_init(struct chery_canfd_aeb_command_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_aeb_command_aeb_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_aeb_command_aeb_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_aeb_command_aeb_active_is_in_range(uint8_t value);

/**
 * Pack message NEW_MSG_51B.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_new_msg_51_b_pack(
    uint8_t *dst_p,
    const struct chery_canfd_new_msg_51_b_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_51B.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_new_msg_51_b_unpack(
    struct chery_canfd_new_msg_51_b_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NEW_MSG_51B.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_new_msg_51_b_init(struct chery_canfd_new_msg_51_b_t *msg_p);

/**
 * Pack message NEW_MSG_51D.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_new_msg_51_d_pack(
    uint8_t *dst_p,
    const struct chery_canfd_new_msg_51_d_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_51D.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_new_msg_51_d_unpack(
    struct chery_canfd_new_msg_51_d_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NEW_MSG_51D.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_new_msg_51_d_init(struct chery_canfd_new_msg_51_d_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_51_d_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_51_d_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_51_d_new_signal_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_51_d_hdc_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_51_d_hdc_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_51_d_hdc_active_is_in_range(uint8_t value);

/**
 * Pack message NEW_MSG_535.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_new_msg_535_pack(
    uint8_t *dst_p,
    const struct chery_canfd_new_msg_535_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_535.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_new_msg_535_unpack(
    struct chery_canfd_new_msg_535_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NEW_MSG_535.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_new_msg_535_init(struct chery_canfd_new_msg_535_t *msg_p);

/**
 * Pack message NEW_MSG_537.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int chery_canfd_new_msg_537_pack(
    uint8_t *dst_p,
    const struct chery_canfd_new_msg_537_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_537.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int chery_canfd_new_msg_537_unpack(
    struct chery_canfd_new_msg_537_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NEW_MSG_537.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int chery_canfd_new_msg_537_init(struct chery_canfd_new_msg_537_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_537_traksi_command_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_537_traksi_command_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_537_traksi_command_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_537_drive_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_537_drive_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_537_drive_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t chery_canfd_new_msg_537_epb_pressed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double chery_canfd_new_msg_537_epb_pressed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool chery_canfd_new_msg_537_epb_pressed_is_in_range(uint8_t value);


#ifdef __cplusplus
}
#endif

#endif
